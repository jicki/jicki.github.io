<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>kubernetes 基础知识 - 小炒肉</title><meta name=Description content="kubernetes 基础知识"><meta property="og:title" content="kubernetes 基础知识"><meta property="og:description" content="kubernetes 基础知识"><meta property="og:type" content="article"><meta property="og:url" content="https://jicki.cn/kubernetes-popularization/"><meta property="og:image" content="https://jicki.cn/logo.png"><meta property="article:published_time" content="2018-01-01T00:00:00+00:00"><meta property="article:modified_time" content="2018-01-01T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jicki.cn/logo.png"><meta name=twitter:title content="kubernetes 基础知识"><meta name=twitter:description content="kubernetes 基础知识"><meta name=application-name content="小炒肉"><meta name=apple-mobile-web-app-title content="小炒肉"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jicki.cn/kubernetes-popularization/><link rel=prev href=https://jicki.cn/kubernetes-1.9-ipvs/><link rel=next href=https://jicki.cn/openshift-3.7.0/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"kubernetes 基础知识","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jicki.cn\/kubernetes-popularization\/"},"genre":"posts","wordcount":11531,"url":"https:\/\/jicki.cn\/kubernetes-popularization\/","datePublished":"2018-01-01T00:00:00+00:00","dateModified":"2018-01-01T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"小炒肉"},"description":"kubernetes 基础知识"}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=小炒肉>小炒肉</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=小炒肉>小炒肉</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/about/>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">kubernetes 基础知识</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://jicki.cn title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>小炒肉</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/kubernetes/><i class="far fa-folder fa-fw"></i>kubernetes</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2018-01-01>2018-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 11531 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 24 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#kubernetes-核心组件>Kubernetes 核心组件</a><ul><li><a href=#master-端>Master 端</a></li><li><a href=#node-端>Node 端</a></li></ul></li><li><a href=#kubernetes-基本对象与术语>Kubernetes 基本对象与术语</a><ul><li><a href=#pod>Pod</a></li><li><a href=#label>Label</a></li><li><a href=#namespace>Namespace</a></li><li><a href=#replicaset>ReplicaSet</a></li><li><a href=#deployment>Deployment</a></li><li><a href=#statefulset>StatefulSet</a></li><li><a href=#daemonset>DaemonSet</a></li><li><a href=#service>Service</a></li><li><a href=#job>Job</a></li><li><a href=#cronjob>CronJob</a></li><li><a href=#horizontal-pod-autoscalerhpa>Horizontal Pod Autoscaler（HPA）</a></li><li><a href=#persistentvolume-pv>PersistentVolume (PV)</a></li><li><a href=#persistentvolumeclaimpvc>PersistentVolumeClaim（PVC）</a></li><li><a href=#storageclass>StorageClass</a></li><li><a href=#commandargsentrypointcmd>Command、Args、Entrypoint、Cmd</a></li></ul></li><li><a href=#pod-的生命周期>Pod 的生命周期</a><ul><li><a href=#初始化容器init-container>初始化容器(init container)</a></li><li><a href=#pod-phase>pod phase</a></li><li><a href=#pod-conditions>Pod conditions</a></li><li><a href=#container-probes>Container probes</a></li><li><a href=#pod-restartpolicy-重启策略>Pod RestartPolicy (重启策略)</a></li><li><a href=#pod-创建过程>Pod 创建过程</a></li></ul></li><li><a href=#kubernetes-资源调度与限制>Kubernetes 资源调度与限制</a><ul><li><a href=#resourcequota>ResourceQuota</a></li><li><a href=#limitrange>LimitRange</a></li><li><a href=#resourcerequestsresourcelimits>ResourceRequests/ResourceLimits</a></li><li><a href=#kubernetes-与-cgroup>kubernetes 与 Cgroup</a></li></ul></li><li><a href=#kubernetes-网络模型>Kubernetes 网络模型</a><ul><li><a href=#kubernetes-通信>Kubernetes 通信</a></li></ul></li><li><a href=#kubernetes-rbac>Kubernetes RBAC</a><ul><li><a href=#角色--clusterrole-与-role->角色 ( ClusterRole 与 Role )</a></li><li><a href=#角色绑定--clusterrolebinding-与-rolebinding->角色绑定 ( ClusterRoleBinding 与 RoleBinding )</a></li><li><a href=#默认角色-与-默认角色绑定>默认角色 与 默认角色绑定</a></li><li><a href=#用户角色>用户角色</a></li></ul></li><li><a href=#api-server-认证机制>API Server 认证机制</a><ul><li><a href=#service-account>Service Account</a></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=kubernetes>Kubernetes</h1><blockquote><p>Kubernetes 是 Google 基于 Borg 开源的容器编排调度，用于管理容器集群自动化部署、扩容以及运维的开源平台。作为云原生计算基金会 CNCF（Cloud Native Computing Foundation）最重要的组件之一（CNCF 另一个毕业项目 Prometheus ），它的目标不仅仅是一个编排系统，而是提供一个规范，可以让你来描述集群的架构，定义服务的最终状态，Kubernetes 可以帮你将系统自动地达到和维持在这个状态，Kubernetes 也可以对容器(Docker)进行集群管理和服务编排（Docker Swarm 类似的功能）,对于大多开发者来说，以容器的方式运行一个程序是一个最基本的需求，跟多的是 Kubernetes 能够提供路由网关、水平扩展、监控、备份、灾难恢复等一系列运维能力。</p></blockquote><ul><li>本文用于科普 <code>Kubernetes</code> 的一些基础知识以及概念。</li></ul><h2 id=kubernetes-核心组件>Kubernetes 核心组件</h2><p><img class=lazyload src=/svg/loading.min.svg data-src=http://jicki.cn/img/posts/kubernetes/kubernetes.png data-srcset="http://jicki.cn/img/posts/kubernetes/kubernetes.png, http://jicki.cn/img/posts/kubernetes/kubernetes.png 1.5x, http://jicki.cn/img/posts/kubernetes/kubernetes.png 2x" data-sizes=auto alt=http://jicki.cn/img/posts/kubernetes/kubernetes.png title=图1></p><ul><li><p><code>Kubernetes</code> 集群由两种角色组成:</p><ul><li><p><code>Master</code> 集群调度节点, 管理集群。(kube-apiserver, kube-controller-manager, kube-scheduler, etcd)</p></li><li><p><code>Node</code> 引用程序实际运行的工作节点。(kubelet, kube-proxy)</p></li></ul></li></ul><h3 id=master-端>Master 端</h3><ul><li><p><code>kube-apiserver</code> 集群控制入口, 提供了 <code>HTTP Rest</code> 接口的关键服务进程，是 <code>Kubernetes</code> 里所有资源的增删改查等操作的唯一入口, 也是集群控制的入口。</p><ul><li><p>提供集群管理的 REST API 接口，包括认证授权、数据校验以及集群状态变更等。</p></li><li><p>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd）</p></li></ul></li><li><p><code>kube-controller-manager</code> 服务运行控制器, 处理常规任务的后台线程 比如故障检测、自动扩展、滚动更新等。kube-controller-manager 由一系列的控制器组成包括如下控制器</p><ul><li><p><code>Replication Controller</code></p></li><li><p><code>Node Controller</code></p></li><li><p><code>CronJob Controller</code></p></li><li><p><code>Daemon Controller</code></p></li><li><p><code>Deployment Controller</code></p></li><li><p><code>Endpoint Controller</code></p></li><li><p><code>Garbage Collector</code></p></li><li><p><code>Namespace Controller</code></p></li><li><p><code>Job Controller</code></p></li><li><p><code>Pod AutoScaler</code></p></li><li><p><code>RelicaSet</code></p></li><li><p><code>Service Controller</code></p></li><li><p><code>ServiceAccount Controller</code></p></li><li><p><code>StatefulSet Controller</code></p></li><li><p><code>Volume Controller</code></p></li><li><p><code>Resource quota Controller</code></p></li></ul></li><li><p><code>kube-scheduler</code> 负责 Pod 资源调度。监视新创建没有分配到Node的Pod, 为Pod选择一个Node。调度方式:</p><ul><li><p>公平调度</p></li><li><p>资源高效利用</p></li><li><p>QoS</p></li><li><p>affinity 和 anti-affinity (约束)</p></li><li><p>数据本地化（data locality）</p></li><li><p>内部负载干扰（inter-workload interference）</p></li><li><p>deadlines</p></li></ul></li><li><p><code>etcd</code> 用于共享配置和服务发现，存储 Kubernetes 集群所有的网络配置和对象的状态信息。</p></li></ul><h3 id=node-端>Node 端</h3><ul><li><p><code>kubelet</code> 负责 Pod 对应的容器的创建，启动等任务，同时与Master节点密切协作, kubelet 提供了一系列<code>PodSpecs</code>集合规范，并确保这些<code>PodSpecs</code>中描述的容器运行正常。 kubelet是主要的节点代理，它会监视已分配给节点的pod, 具体功能</p><ul><li><p>安装 Pod 所需的volume。</p></li><li><p>下载 Pod 的Secrets。</p></li><li><p>监控 Pod 中运行的 docker（或experimentally，rkt）容器。</p></li><li><p>定期执行容器健康检查。</p></li><li><p>回传 pod 的状态到其他 kubernetes 服务中。</p></li><li><p>回传 节点 的状态到其他 kubernetes 服务中。</p></li></ul></li><li><p><code>kube-proxy</code> 实现 Kubernetes SVC 的通信与负载均衡机制的重要组件。通过在主机上维护网络规则并执行连接转发来实现Kubernetes服务抽象。</p></li></ul><h2 id=kubernetes-基本对象与术语>Kubernetes 基本对象与术语</h2><h3 id=pod>Pod</h3><ul><li>Pod 是一组紧密关联的容器集合，它们共享 <code>PID</code>、<code>IPC</code>、<code>Network</code> 和 <code>UTS namespace</code>，是 Kubernetes 调度的基本单位。Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</li></ul><h3 id=label>Label</h3><ul><li><p>Label 是识别 Kubernetes 对象的标签，以 <code>key/value</code> 的方式附加到对象上（key最长不能超过63字节，value 可以为空，也可以是不超过253字节的字符串）。 Label 不提供唯一性，并且实际上经常是很多对象（如 Pods）都使用相同的 label 来标志具体的应用。 Label 定义好后其他对象可以使用 Label Selector 来选择一组相同 label 的对象（比如 Service 用 label 来选择一组 Pod）。Label Selector 支持以下几种方式:</p><ul><li><p>等于和不等于, 如app=nginx和env!=production</p></li><li><p>集合，如env in (production, test)</p></li><li><p>多个label（它们之间是AND关系），如app=nginx, env=test</p></li></ul></li></ul><h3 id=namespace>Namespace</h3><ul><li>Namespace 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的 pods, services, deployments 等都是属于某一个 namespace 的（默认是default），而 Node, PersistentVolumes 等则不属于任何 namespace。</li></ul><h3 id=replicaset>ReplicaSet</h3><ul><li>ReplicaSet 它的主要作用是确保 <code>Pod</code> 以你指定的副本数运行, 如果有容器异常退出, 会自动创建新的 <code>Pod</code> 来替代, 而异常多出来的容器也会自动回收。 支持集合式的 <code>selector</code>。ReplicaSet 可以独立使用, 但建议使用 <code>Deployment</code> 来自动管理 ReplicaSet, 这样就无需担心跟其他机制的不兼容问题（比如 ReplicaSet 不支持 rolling-update 但 Deployment 支持）, 并且 <code>Deployment</code> 还支持版本记录、回滚、暂停升级等高级特性。</li></ul><h3 id=deployment>Deployment</h3><ul><li><p>Deployment 确保任意时间都有指定数量的 <code>Pod</code> 在运行。如果为某个 <code>Pod</code> 创建了 Deployment 并且指定3个副本，它会创建3个 Pod，并且持续监控它们。如果某个 Pod 不响应，那么 Deployment 会替换它，保持总数为3。如果之前不响应的 Pod 恢复了，现在就有4个 Pod 了，那么 Deployment 会将其中一个终止保持总数为3。如果在运行中将副本总数改为5，Deployment 会立刻启动2个新 Pod，保证总数为5。Deployment 还支持回滚和滚动升级。</p></li><li><p>创建 Deployment 需要指定:</p><ul><li><p>Pod 模板 用于配置 pod 生成的属性和副本。</p></li><li><p>Label 标签 Deployment 需要监控的 Pod 的标签。</p></li></ul></li></ul><h3 id=statefulset>StatefulSet</h3><ul><li><p>StatefulSet 是为了解决有状态服务的问题 (对应 Deployments 和 ReplicaSets是为无状态服务而设计), 其应用场景包括</p><ul><li><p>稳定的持久化存储，即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现。</p></li><li><p>稳定的网络标志，即 Pod 重新调度后其 <code>PodName</code> 和 <code>HostName</code> 不变，基于 Headless Service（即没有Cluster IP的Service）来实现</p></li><li><p>有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers来实现。</p></li><li><p>有序收缩，有序删除（即从N-1到0）</p></li></ul></li></ul><h3 id=daemonset>DaemonSet</h3><ul><li>DaemonSet 保证在每个Node上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。</li></ul><h3 id=service>Service</h3><ul><li>Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。匹配 labels 的Pod IP 和端口列表组成 endpoints，由 kube-proxy 负责将服务 IP 负载均衡到这些endpoints 上。每个 Service 都会自动分配一个 cluster IP（仅在集群内部可访问的虚拟地址）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。</li></ul><h3 id=job>Job</h3><ul><li><p>Job 负责批量处理短暂的一次性任务 (short lived one-off tasks)，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束。</p></li><li><p>Kubernetes 支持以下几种 Job</p><ul><li><p>非并行 Job：通常创建一个 Pod 直至其成功结束</p></li><li><p>固定结束次数的 Job：设置 <code>.spec.completions</code>, 创建多个 Pod，直到 <code>.spec.completions</code> 个 Pod 成功结束</p></li><li><p>带有工作队列的并行 Job：设置 <code>.spec.Parallelism</code> 但不设置 <code>.spec.completions</code>，当所有Pod结束并且至少一个成功时，Job 就认为是成功</p></li></ul></li></ul><h3 id=cronjob>CronJob</h3><ul><li>CronJob 即定时任务，就类似于 Linux 系统的 crontab，在指定的时间周期运行指定的任务。</li></ul><h3 id=horizontal-pod-autoscalerhpa>Horizontal Pod Autoscaler（HPA）</h3><ul><li>Horizontal Pod Autoscaling 可以根据 CPU 使用率或应用自定义 metrics 自动扩展 Pod 数量（支持replication controller、deployment和replica set）, 从而合理的扩展性能与使用资源。</li></ul><h3 id=persistentvolume-pv>PersistentVolume (PV)</h3><ul><li><p>PersistentVolume（PV）是集群中由管理员配置的一段网络存储。 它是集群中的资源，就像节点是集群资源一样。 PV是容量插件，如Volumes，但其生命周期独立于使用PV的任何单个pod。 此API对象捕获存储实现的详细信息，包括NFS，iSCSI或特定于云提供程序的存储系统。</p></li><li><p>PersistentVolume 支持的类型:</p><ul><li><p>GCEPersistentDisk</p></li><li><p>AWSElasticBlockStore</p></li><li><p>AzureFile</p></li><li><p>AzureDisk</p></li><li><p>FC (Fibre Channel)</p></li><li><p>Flexvolume</p></li><li><p>Flocker</p></li><li><p>NFS</p></li><li><p>iSCSI</p></li><li><p>RBD (Ceph Block Device)</p></li><li><p>CephFS</p></li><li><p>Cinder (OpenStack block storage)</p></li><li><p>Glusterfs</p></li><li><p>VsphereVolume</p></li><li><p>Quobyte Volumes</p></li><li><p>HostPath</p></li><li><p>Portworx Volumes</p></li><li><p>ScaleIO Volumes</p></li><li><p>StorageOS</p></li></ul></li><li><p>PersistentVolume 服务状态</p><ul><li><p><code>Available</code> 资源尚未被claim使用</p></li><li><p><code>Bound</code> 卷已经被绑定到claim了</p></li><li><p><code>Released</code> claim被删除，卷处于释放状态，但未被集群回收。</p></li><li><p><code>Failed</code> 卷自动回收失败</p></li></ul></li></ul><h3 id=persistentvolumeclaimpvc>PersistentVolumeClaim（PVC）</h3><ul><li><p>PersistentVolumeClaim（PVC）是由用户进行存储的请求。 它类似于pod。 Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源（CPU和内存）。声明可以请求特定的大小和访问模式（例如，可以一次读/写或多次只读）。</p></li><li><p>PVC和PV是一一对应的。</p></li><li><p>PVC 与 PV 的生命周期</p><ul><li><p>PV是群集中的资源。PVC是对这些资源的请求，并且还充当对资源的检查。</p></li><li><p>PV和PVC之间的相互作用遵循生命周期：<code>Provisioning</code> ——-> <code>Binding</code> ——–> <code>Using</code> -——> <code>Releasing</code> -——> <code>Recycling</code></p></li></ul></li><li><p>Provisioning (准备) 通过集群外的存储系统或者云平台来提供存储持久化支持。</p><ul><li><p>静态提供Static：集群管理员创建多个PV。 它们携带可供集群用户使用的真实存储的详细信息。 它们存在于Kubernetes API中，可用于消费。</p></li><li><p>动态提供Dynamic：当管理员创建的静态PV都不匹配用户的PersistentVolumeClaim时，集群可能会尝试为PVC动态配置卷。 此配置基于StorageClasses：PVC必须请求一个类，并且管理员必须已创建并配置该类才能进行动态配置。 要求该类的声明有效地为自己禁用动态配置。</p></li></ul></li><li><p>Binding (绑定) 用户创建pvc并指定需要的资源和访问模式。在找到可用pv之前，pvc会保持未绑定状态。</p></li><li><p>Using (使用) 用户可在pod中像volume一样使用pvc。</p></li><li><p>Releasing (释放) 用户删除pvc来回收存储资源，pv将变成"released"状态。由于还保留着之前的数据，这些数据需要根据不同的策略来处理，否则这些存储资源无法被其他pvc使用。</p></li><li><p>Recycling (回收) pv 可以设置三种回收策略：保留（Retain），回收（Recycle）和删除（Delete）。</p><ul><li><p>保留策略 - 允许人工处理保留的数据。</p></li><li><p>删除策略 - 将删除pv和外部关联的存储资源，需要插件支持。</p></li><li><p>回收策略 - 将执行清除操作，之后可以被新的pvc使用，需要插件支持。</p></li></ul></li></ul><h3 id=storageclass>StorageClass</h3><ul><li>StorageClass为管理员提供了一种描述他们提供的存储的"类"的方法。 不同的类可能映射到服务质量级别，或备份策略，或者由群集管理员确定的任意策略。 Kubernetes本身对于什么类别代表是不言而喻的。 这个概念有时在其他存储系统中称为"配置文件&rdquo;。</li></ul><h3 id=commandargsentrypointcmd>Command、Args、Entrypoint、Cmd</h3><ul><li><p><code>Command</code>、<code>Args</code> 是属于 <code>kubernetes</code> 的命令</p></li><li><p><code>Entrypoint</code>、<code>Cmd</code> 是属于 <code>Docker</code> 的命令</p></li><li><p>在<code>kubernetes</code> 于 <code>Docker image</code> 中都分别包含命令的情况下:</p><ul><li><p>如果 <code>command</code> 和 <code>args</code> 均没有写, 那么用 <code>Docker image</code> 默认的配置。</p></li><li><p>如果 <code>command</code> 写了, 但 <code>args</code> 没有写, 那么<code>Docker</code> 默认的配置会被忽略而且仅仅执行<code>kubernetes</code> 的 <code>command</code>（不带任何参数的）。</p></li><li><p>如果 <code>command</code> 没写, 但 <code>args</code> 写了, 那么<code>Docker</code> 默认配置的 <code>Entrypoint</code> 命令行会被执行, 但是调用的参数是 <code>kubernetes</code> 的 <code>args</code>。</p></li><li><p>如果 <code>command</code> 和 <code>args</code> 都写了, 那么<code>Docker</code> 默认的配置会被忽略, 而使用 <code>kubernetes</code> 的配置。</p></li></ul></li></ul><h2 id=pod-的生命周期>Pod 的生命周期</h2><ul><li><p>Pod对象自从其创建开始至其终止退出的时间范围称为其生命周期。</p><ol><li><p>创建主容器（main container）为 <code>必需</code>的操作。</p></li><li><p>初始化容器（init container）。</p></li><li><p>容器启动后钩子（post start hook）。</p></li><li><p>容器的存活性探测（liveness probe）。</p></li><li><p>就绪性探测（readiness probe）。</p></li><li><p>容器终止前钩子（pre stop hook）</p></li><li><p>其他Pod的定义操作。</p></li></ol></li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=http://jicki.cn/img/posts/kubernetes/pod.png data-srcset="http://jicki.cn/img/posts/kubernetes/pod.png, http://jicki.cn/img/posts/kubernetes/pod.png 1.5x, http://jicki.cn/img/posts/kubernetes/pod.png 2x" data-sizes=auto alt=http://jicki.cn/img/posts/kubernetes/pod.png title=图2></p><h3 id=初始化容器init-container>初始化容器(init container)</h3><ul><li><p>初始化容器（init container）即应用程序的主容器启动之前要运行的容器，常用于为主容器执行一些预置操作，它们具有两
种典型特征。</p><ol><li><p>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成。（注意：如果pod的<code>spec.restartPolicy</code>字段值为 <code>Never</code>，那么运行失败的初始化容器不会被重启。）</p></li><li><p>每个初始化容器都必须按定义的顺序串行运行。</p></li></ol></li></ul><h3 id=pod-phase>pod phase</h3><ul><li>Pod 的 status 属性是一个 <code>PodStatus</code> 对象，拥有一个 phase 字段。它简单描述了 Pod 在其生命周期的阶段。</li></ul><table><thead><tr><th>pod phase</th><th>描述</th></tr></thead><tbody><tr><td>挂起(Pending)</td><td>kubernetes 通过<code>apiserver</code>创建了pod 资源对象并存入etcd中, 但它尚未被调度完成, 或者仍处于从仓库下载镜像的过程中</td></tr><tr><td>运行中(Running)</td><td>Pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成，至少一个容器正在运行。</td></tr><tr><td>成功(Succeeded)</td><td>Pod中的所有容器都已经成功并且不会被重启。</td></tr><tr><td>失败(Failed)</td><td>Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。即容器以非0状态退出或者被系统禁止。</td></tr><tr><td>未知(Unknown)</td><td><code>ApiServer</code> 无法正常获取到Pod对象的状态信息，通常是由于无法与所在工作节点的kubelet通信所致。</td></tr></tbody></table><h3 id=pod-conditions>Pod conditions</h3><ul><li><p>Pod 的 status 属性是一个 <code>PodStatus</code> 对象, 里面包含 PodConditions 数组，代表 Condition 是否通过。</p></li><li><p>PodCondition 属性描述</p></li></ul><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>lastProbeTime</td><td>最后一次探测 Pod Condition 的时间戳。</td></tr><tr><td>lastTransitionTime</td><td>上次 Condition 从一种状态转换到另一种状态的时间。</td></tr><tr><td>message</td><td>上次 Condition 状态转换的详细描述。</td></tr><tr><td>reason</td><td>Condition 最后一次转换的原因。</td></tr><tr><td>status</td><td>Condition 状态类型，可以为 True False Unknown</td></tr><tr><td>type</td><td>Condition类型(PodScheduled, Ready, Initialized, Unschedulable, ContainersReady)</td></tr></tbody></table><ul><li><p>Condition Type 说明</p><ul><li><p><code>PodScheduled</code> Pod 已被调度到一个节点</p></li><li><p><code>Ready</code> Pod 能够提供请求，应该被添加到负载均衡池中以提供服务</p></li><li><p><code>Initialized</code> 所有 init containers 成功启动</p></li><li><p><code>Unschedulable</code> 调度器不能正常调度容器，例如缺乏资源或其他限制</p></li><li><p><code>ContainersReady</code> Pod 中所有容器全部就绪</p></li></ul></li></ul><h3 id=container-probes>Container probes</h3><ul><li><p>Probe 是在容器上 kubelet 的定期执行的诊断，kubelet 通过调用容器实现的 Handler 来诊断。</p><ul><li><p><code>Success</code> 容器诊断通过。</p></li><li><p><code>Failure</code> 容器诊断失败。</p></li><li><p><code>Unknown</code> 诊断失败，因此不应采取任何措施。</p></li></ul></li><li><p>Handlers 包含如下三种</p><ul><li><p><code>ExecAction</code> 在容器内部执行指定的命令，如果命令以状态代码 0 退出，则认为诊断成功。</p></li><li><p><code>TCPSocketAction</code> 对指定 IP 和端口的容器执行 TCP 检查，如果端口打开，则认为诊断成功。</p></li><li><p><code>HTTPGetAction</code> 对指定 IP + port + path 路径上的容器的执行 HTTP Get 请求。如果响应的状态代码大于或等于 200 且小于 400，则认为诊断成功。</p></li></ul></li><li><p>kubelet 可以选择性地对运行中的容器进行两种探测器执行和响应。</p><ul><li><p><code>livenessProbe</code> 存活性探测, 探测容器是否正在运行，如果活动探测失败，则 kubelet 会杀死容器，并且容器将受其 重启策略 的约束。如果不指定活动探测, 默认状态是 Success。</p></li><li><p><code>readinessProbe</code> 就绪性探测, 探测容器是否已准备好为请求提供服务，如果准备情况探测失败，则控制器会从与 Pod 匹配的所有服务的端点中删除 Pod 的 IP 地址。初始化延迟之前的默认准备状态是 <code>Failure</code>, 如果容器未提供准备情况探测，则默认状态为 Success。</p></li></ul></li><li><p>以下为 Nginx 应用的两种探针配置示例</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>apiVersion: apps/v1
kind: Deployment 
metadata: 
  name: nginx-dm
spec: 
  replicas: <span class=m>2</span>
  selector:
    matchLabels:
      name: nginx
  template: 
    metadata: 
      labels: 
        name: nginx 
    spec: 
      containers: 
        - name: nginx 
          image: nginx:alpine 
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: <span class=m>80</span>
              name: http
          <span class=c1># readinessProbe - 检测pod 的 Ready 是否为 true</span>
          readinessProbe:
            tcpSocket:
              port: <span class=m>80</span>
            <span class=c1># 启动后5s 开始检测</span>
            initialDelaySeconds: <span class=m>5</span>  
            <span class=c1># 检测 间隔为 10s</span>
            periodSeconds: <span class=m>10</span>
          <span class=c1># livenessProbe - 检测 pod 的 State 是否为 Running</span>
          livenessProbe:
            httpGet:
              path: /
              port: <span class=m>80</span>
            <span class=c1># 启动后 15s 开始检测</span>
            <span class=c1># 检测时间必须在 readinessProbe 之后</span>
            initialDelaySeconds: <span class=m>15</span>
            <span class=c1># 检测 间隔为 20s</span>
            periodSeconds: <span class=m>20</span>
</code></pre></td></tr></table></div></div><h3 id=pod-restartpolicy-重启策略>Pod RestartPolicy (重启策略)</h3><ul><li><p>PodSpec 中有一个<code>restartPolicy</code>字段，可能的值为Always、OnFailure和Never。默认为Always。restartPolicy适用于Pod中的所有容器。而且它仅用于控制在同一节点上重新启动Pod对象的相关容器。</p></li><li><p>首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长依次为10秒、20秒、40秒&mldr; 300秒是最大延迟时长。</p></li><li><p>Pod，一旦绑定到一个节点，Pod对象将永远不会被重新绑定到另一个节点，它要么被重启，要么终止，直到节点发生故障或被删除。</p></li></ul><h3 id=pod-创建过程>Pod 创建过程</h3><ul><li><p>创建一个 pod 的过程</p><ol><li><p>用户通过kubectl或其他API客户端提交了Pod Spec给API Server。</p></li><li><p>API Server尝试着将Pod对象的相关信息存入etcd中，待写入操作执行完成，API Server即会返回确认信息至客户端。</p></li><li><p>API Server开始检测etcd中的状态变化。</p></li><li><p>所有的kubernetes组件均使用<code>watch</code>机制来跟踪检查API Server上的相关的变动。</p></li><li><p>kube-scheduler（调度器）通过其<code>watcher</code>觉察到API Server创建了新的Pod对象但尚未绑定至任何工作节点。</p></li><li><p>kube-scheduler（调度器）为Pod对象挑选一个工作节点并将结果信息更新至API Server。</p></li><li><p>调度结果信息由API Server更新至etcd存储系统，而且API Server也开始反映此Pod对象的调度结果。</p></li><li><p>Pod被调度到的目标工作节点上的kubelet尝试在当前节点上调用Docker启动容器，并将容器的结果状态返回送至API Server。</p></li><li><p>API Server将Pod状态信息存入etcd系统中。</p></li><li><p>在etcd确认写入操作成功完成后，API Server将确认信息发送至相关的kubelet，事件将通过它被接受。</p></li></ol></li></ul><h2 id=kubernetes-资源调度与限制>Kubernetes 资源调度与限制</h2><ul><li><p>在 Kubernetes 体系中，资源默认是被多租户多应用共享使用的，应用与租户间不可避免地存在资源竞争问题。</p></li><li><p>在 Kubernetes 中支持分别从 <code>Namespace</code>、<code>Pod</code> 和 <code>Container</code> 三个级别对资源进行管理。</p></li><li><p>在 Kubernetes 将 cpu 1 Core (核) = 1000m, <code>m</code> 这个单位表示 千分之一核, 2000m 表示 两个完整的核心, 也可以写成<code>2</code> 或者 <code>2.0</code>。</p></li></ul><h3 id=resourcequota>ResourceQuota</h3><ul><li><p><code>Namespace</code> 级别, 可以通过创建 <code>ResourceQuota</code> 对象对<code>Namespace</code>进行绑定, 提供一个总体资源使用量限制。</p><ol><li><p>可以设置该命名空间中 Pod 可以使用到的计算资源（CPU、内存）、存储资源总量上限。</p></li><li><p>可以限制该 Namespace 中某种类型对象（如 Pod、RC、Service、Secret、ConfigMap、PVC 等）的总量上限。</p></li></ol></li><li><p>ResourceQuota 示例</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>apiVersion: v1
kind: ResourceQuota
metadata:
  name: quota
spec:
  hard:
    requests.cpu: <span class=s2>&#34;20&#34;</span>
    requests.memory: 30Gi
    requests.storage: 500Gi
    requests.ephemeral-storage: 10Gi
    limits.cpu: <span class=s2>&#34;40&#34;</span>
    limits.memory: 60Gi
    limits.ephemeral-storage: 20Gi
    pods: <span class=s2>&#34;10&#34;</span>
    services: <span class=s2>&#34;5&#34;</span>
    replicationcontrollers: <span class=s2>&#34;20&#34;</span>
    resourcequotas: <span class=s2>&#34;1&#34;</span>
    secrets: <span class=s2>&#34;10&#34;</span>
    configmaps: <span class=s2>&#34;10&#34;</span>
    persistentvolumeclaims: <span class=s2>&#34;10&#34;</span>
    services.nodeports: <span class=s2>&#34;50&#34;</span>
    services.loadbalancers: <span class=s2>&#34;10&#34;</span>

</code></pre></td></tr></table></div></div><ul><li><p><code>requests</code> kubernetes会根据Request的值去查找有足够资源的node来调度此pod, 既超过了 Request 限制的值, Pod 将不会被调度到此node中。</p></li><li><p><code>limits</code> 对应资源量的上限, 既最多允许使用这个上限的资源量, 由于cpu是可压缩的, 进程是无法突破上限的, 而memory是不可压缩资源, 当进程试图请求超过limit限制时的memory, 此进程就会被kubernetes杀掉。</p></li></ul><h3 id=limitrange>LimitRange</h3><ul><li>LimitRange 对象设置 Namespace 中 Pod 及 Container 的默认资源配额和资源限制。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>apiVersion: v1
kind: LimitRange
metadata:
  name: limit
spec:
  limits:
  - type: Pod
    max:
      cpu: <span class=s2>&#34;10&#34;</span>
      memory: 100Gi
    min:
      cpu: 200m
      memory: 6Mi
    maxLimitRequestRatio:
      cpu: <span class=s2>&#34;2&#34;</span>
      memory: <span class=s2>&#34;4&#34;</span>
  - type: Container
    max:
      cpu: <span class=s2>&#34;2&#34;</span>
      memory: 1Gi
    min:
      cpu: 100m
      memory: 3Mi
    default:
      cpu: 300m
      memory: 200Mi
    defaultRequest:
      cpu: 200m
      memory: 100Mi
    maxLimitRequestRatio:
      cpu: <span class=s2>&#34;2&#34;</span>
      memory: <span class=s2>&#34;4&#34;</span>
  - type: PersistentVolumeClaim
    max:
      storage: 10Gi
    min:
      storage: 5Gi
</code></pre></td></tr></table></div></div><ul><li><p><code>pod</code> 与 <code>Container</code> 以及 <code>pvc</code> 类型可分开定义 <code>LimitRange</code> 分配资源。</p></li><li><p><code>limits</code> 字段下面的 <code>default</code> 字段表示每个 Pod 的默认的 limits 配置，所以任何没有分配资源的 limits 的 Pod 都会被自动分配 200Mi limits 的内存和 300m limits 的 CPU。</p></li><li><p><code>defaultRequest</code> 字段表示每个 Pod 的默认 requests 配置，所以任何没有分配资源的 requests 的 Pod 都会被自动分配 100Mi requests 的内存和 200m requests 的 CPU。</p></li><li><p><code>max</code> 与 <code>min</code> 字段分别限制 type 类型下的 服务最大与最小的限制值。</p></li></ul><h3 id=resourcerequestsresourcelimits>ResourceRequests/ResourceLimits</h3><ul><li><p>在 Container 级别可以对两种计算资源进行管理 <code>CPU</code> 和 <code>内存</code>。</p></li><li><p><code>ResourceRequests</code> 表示容器希望被分配到的可完全保证的资源量，Requests 的值会被提供给 Kubernetes 调度器，以便优化基于资源请求的容器调度。</p></li><li><p><code>ResourceLimits</code> 表示容器能用的资源上限，这个上限的值会影响在节点上发生资源竞争时的解决策略。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>apiVersion: v1
kind: Pod
metadata:
  name: busybox
spec:
  containers:
   - name: busybox
     image: busybox
     resources:
       requests:
         memory: <span class=s2>&#34;100Mi&#34;</span>
         cpu: <span class=s2>&#34;200m&#34;</span>
       limits:
         memory: <span class=s2>&#34;200Mi&#34;</span>
         cpu: <span class=s2>&#34;250m&#34;</span>
</code></pre></td></tr></table></div></div><h3 id=kubernetes-与-cgroup>kubernetes 与 Cgroup</h3><blockquote><p>Kubernetes 对内存资源的限制实际上是通过 cgroup 来控制的，cgroup 是容器的一组用来控制内核如何运行进程的相关属性集合。针对内存、CPU 和各种设备都有对应的 cgroup。cgroup 是具有层级的，这意味着每个 cgroup 拥有一个它可以继承属性的父亲，往上一直直到系统启动时创建的 root cgroup。</p></blockquote><ul><li><p>内存 限制</p><ul><li>Kubernetes 通过 cgroup 和 OOM killer 来限制 Pod 的内存资源，当超过内存限制值以后, Kubernetes 会选择好几个进程作为 <code>OOM killer</code> 候选人, 其中最重要的进程是标注为 <code>pause</code> 的进程, 用来为业务容器创建共享的 <code>network</code> 和 <code>namespace</code>, 其 <code>oom_score_adj</code> 值为 <code>-998</code>，可以确保不被杀死。<code>oom_score_adj</code> 值越低就越不容易被杀死, 因为业务容器内<code>pause</code> 之外的所有其他进程的 <code>oom_score_adj</code> 值都相同，所以谁的内存使用量最多，<code>oom_score</code> 值就越高，也就越容易被杀死。</li></ul></li><li><p>CPU 限制</p><ul><li><p>在 Kubernetes 中设置的 cpu requests 最终会被 cgroup 设置为 <code>cpu.shares</code> 属性的值， cpu limits 会被带宽控制组设置为<code>cpu.cfs_period_us</code> 和 <code>cpu.cfs_quota_us</code> 属性的值。与内存一样，cpu requests 主要用于在调度时通知调度器节点上至少需要多少个 cpu shares 才可以被调度。</p></li><li><p>cpu requests 与 内存 requests 不同，设置了 cpu requests 会在 cgroup 中设置一个属性，以确保内核会将该数量的 shares 分配给进程。</p></li><li><p>cpu limits 与 内存 limits 也有所不同。如果容器进程使用的内存资源超过了内存使用限制，那么该进程将会成为 oom-killing 的候选者。但是容器进程基本上永远不能超过设置的 CPU 配额，所以容器永远不会因为尝试使用比分配的更多的 CPU 时间而被驱逐。系统会在调度程序中强制进行 CPU 资源限制，以确保进程不会超过这个限制。</p></li></ul></li></ul><h2 id=kubernetes-网络模型>Kubernetes 网络模型</h2><ul><li><p>Kubernetes 中每个Pod 都拥有一个独立的IP地址，而且假定所有Pod 都在一个可以直接连通的、扁平的网络空间中，不管是否运行在同一Node上都可以通过Pod的IP来访问。</p></li><li><p>Kubernetes 中Pod的IP是最小粒度IP。同一个Pod内所有的容器共享一个网络堆栈，该模型称为IP-per-Pod模型。</p></li></ul><h3 id=kubernetes-通信>Kubernetes 通信</h3><ul><li><p>同一个 Node 下, 同一个 pod 内</p></li><li><p>同一个Pod的容器共享同一个网络命名空间, 它们之间的访问可以用 Pod IP 地址 + 容器端口就可以访问。</p></li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=http://jicki.cn/img/posts/kubernetes/node-pod.png data-srcset="http://jicki.cn/img/posts/kubernetes/node-pod.png, http://jicki.cn/img/posts/kubernetes/node-pod.png 1.5x, http://jicki.cn/img/posts/kubernetes/node-pod.png 2x" data-sizes=auto alt=http://jicki.cn/img/posts/kubernetes/node-pod.png title=图3></p><ul><li>同一个 Node 下, 不同的 pod 之间通信</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=http://jicki.cn/img/posts/kubernetes/node-pod-pod.png data-srcset="http://jicki.cn/img/posts/kubernetes/node-pod-pod.png, http://jicki.cn/img/posts/kubernetes/node-pod-pod.png 1.5x, http://jicki.cn/img/posts/kubernetes/node-pod-pod.png 2x" data-sizes=auto alt=http://jicki.cn/img/posts/kubernetes/node-pod-pod.png title=图4></p><ul><li>不同的 Node 之间, pod 与 pod 使用 网络组件进行通信</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=http://jicki.cn/img/posts/kubernetes/node-node-pod.gif data-srcset="http://jicki.cn/img/posts/kubernetes/node-node-pod.gif, http://jicki.cn/img/posts/kubernetes/node-node-pod.gif 1.5x, http://jicki.cn/img/posts/kubernetes/node-node-pod.gif 2x" data-sizes=auto alt=http://jicki.cn/img/posts/kubernetes/node-node-pod.gif title=图5></p><h2 id=kubernetes-rbac>Kubernetes RBAC</h2><ul><li>基于角色的访问控制（Role-Based Access Control, 即 &ldquo;RBAC&rdquo;）: 使用 “rbac.authorization.k8s.io” API Group 实现授权决策，允许管理员通过 Kubernetes API 动态配置策略。</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=http://jicki.cn/img/posts/kubernetes/rbac.png data-srcset="http://jicki.cn/img/posts/kubernetes/rbac.png, http://jicki.cn/img/posts/kubernetes/rbac.png 1.5x, http://jicki.cn/img/posts/kubernetes/rbac.png 2x" data-sizes=auto alt=http://jicki.cn/img/posts/kubernetes/rbac.png title=图6></p><h3 id=角色--clusterrole-与-role->角色 ( ClusterRole 与 Role )</h3><ul><li><p><code>Role（角色）</code> 是一系列权限的集合，例如一个角色可以包含读取 Pod 的权限和列出 Pod 的权限。</p><ul><li>Role 只能用来给某个特定 namespace 中的资源作鉴权。</li></ul></li><li><p>如下是 role 对象的定义的一个 demo 授予 default 这个 namespaces 下的 pods 的权限</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: default
  name: demo-role
rules:
- apiGroups: <span class=o>[</span><span class=s2>&#34;&#34;</span><span class=o>]</span>  <span class=c1># 空字符串&#34;&#34;表明使用 core API group</span>
  resources: <span class=o>[</span><span class=s2>&#34;pods&#34;</span><span class=o>]</span>
  verbs: <span class=o>[</span><span class=s2>&#34;get&#34;</span>, <span class=s2>&#34;watch&#34;</span>, <span class=s2>&#34;list&#34;</span>, <span class=s2>&#34;create&#34;</span>, <span class=s2>&#34;delete&#34;</span><span class=o>]</span>
</code></pre></td></tr></table></div></div><ul><li><p>大多数资源由代表其名字的字符串表示，例如 ”pods”，就像它们出现在相关API endpoint 的URL中一样。然而，有一些Kubernetes API还 包含了”子资源”，比如 pod 的 logs。</p></li><li><p>在Kubernetes中，pod logs endpoint的URL格式为：<code>GET /api/v1/namespaces/{namespace}/pods/{name}/log</code></p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: default
  name: pod-and-pod-logs-reader
rules:
- apiGroups: <span class=o>[</span><span class=s2>&#34;&#34;</span><span class=o>]</span>
  resources: <span class=o>[</span><span class=s2>&#34;pods&#34;</span>, <span class=s2>&#34;pods/log&#34;</span><span class=o>]</span>
  verbs: <span class=o>[</span><span class=s2>&#34;get&#34;</span>, <span class=s2>&#34;list&#34;</span><span class=o>]</span>
</code></pre></td></tr></table></div></div><ul><li><p>通过 <code>resourceNames</code> 列表，角色可以针对不同种类的请求根据资源名引用资源实例。</p></li><li><p>当指定了 <code>resourceNames</code> 列表时，不同动作 种类的请求的权限，如使用 ”get”、”delete”、”update”以及”patch”等动词的请求，将被限定到资源列表中所包含的资源实例上。</p></li><li><p>值得注意的是，如果设置了 resourceNames，则请求所使用的动词不能是 list、watch、create或者delete collection。由于资源名不会出现在 create、list、watch和delete collection 等API请求的URL中，所以这些请求动词不会被设置了resourceNames 的规则所允许，因为规则中的 resourceNames 部分不会匹配这些请求。</p></li><li><p>如下 如果需要限定一个角色绑定主体只能 ”get” 或者 ”update” 指定的一个 configmap</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: default
  name: configmap-updater
rules:
- apiGroups: <span class=o>[</span><span class=s2>&#34;&#34;</span><span class=o>]</span>
  resources: <span class=o>[</span><span class=s2>&#34;configmap&#34;</span><span class=o>]</span>
  resourceNames: <span class=o>[</span><span class=s2>&#34;my-configmap&#34;</span><span class=o>]</span>
  verbs: <span class=o>[</span><span class=s2>&#34;update&#34;</span>, <span class=s2>&#34;get&#34;</span><span class=o>]</span>

</code></pre></td></tr></table></div></div><ul><li><p><code>ClusterRole</code> 对象可以授予与 Role 对象相同的权限，但由于它们属于集群范围对象，也可以使用它们授予对以下几种资源的访问权限</p><ul><li><p>集群范围资源（例如节点，即 node）</p></li><li><p>非资源类型 endpoint（例如 /healthz）</p></li><li><p>授权多个 Namespace</p></li></ul></li><li><p>如下是 ClusterRole 定义可用于授予用户对某一个 namespace，或者 所有 namespace 的 secret（取决于其绑定方式）的读访问权限</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  <span class=c1># ClusterRole 是集群范围对象，没有 &#34;namespace&#34; 区分</span>
  name: demo-clusterrole
rules:
- apiGroups: <span class=o>[</span><span class=s2>&#34;&#34;</span><span class=o>]</span>
  resources: <span class=o>[</span><span class=s2>&#34;secrets&#34;</span><span class=o>]</span>
  verbs: <span class=o>[</span><span class=s2>&#34;get&#34;</span>, <span class=s2>&#34;watch&#34;</span>, <span class=s2>&#34;list&#34;</span>, <span class=s2>&#34;create&#34;</span>, <span class=s2>&#34;delete&#34;</span><span class=o>]</span>
</code></pre></td></tr></table></div></div><h3 id=角色绑定--clusterrolebinding-与-rolebinding->角色绑定 ( ClusterRoleBinding 与 RoleBinding )</h3><ul><li><p><code>RoleBinding</code> 把 Role 或 ClusterRole 中定义的各种权限映射到 <code>User</code>，<code>Service Account</code> 或者 <code>Group</code>，从而让这些用户继承角色在 namespace 中的权限。</p></li><li><p>如下是 RoleBinding 引用在同一命名空间内定义的Role对象。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell><span class=c1># 以下角色绑定定义将允许用户 &#34;jane&#34; 从 &#34;default&#34; 命名空间中读取pod</span>
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: read-pods
  namespace: default
subjects:
- kind: User
  name: jane
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io

</code></pre></td></tr></table></div></div><ul><li><p><code>RoleBinding</code> 对象也可以引用一个 ClusterRole 对象用于在 RoleBinding 所在的命名空间内授予用户对所引用的ClusterRole 中定义的命名空间资源的访问权限。这一点允许管理员在整个集群范围内首先定义一组通用的角色，然后再在不同的命名空间中复用这些角色。</p></li><li><p>如下 RoleBinding 引用的是一个 ClusterRole 对象，但是用户”dave”（即角色绑定主体）还是只能读取”development” 命名空间中的 secret（即RoleBinding所在的命名空间）</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell><span class=c1># 以下角色绑定允许用户&#34;dave&#34;读取&#34;development&#34;命名空间中的secret。</span>
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: read-secrets
  namespace: development <span class=c1># 这里表明仅授权读取&#34;development&#34;命名空间中的资源。</span>
subjects:
- kind: User
  name: dave
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
</code></pre></td></tr></table></div></div><ul><li><p><code>ClusterRoleBinding</code> 让用户继承 ClusterRole 在整个集群中的权限。</p></li><li><p>如下使用 ClusterRoleBinding 在集群级别和所有命名空间中授予权限。下面示例中所定义的 ClusterRoleBinding 允许在用户组 ”manager” 中的任何用户都可以读取集群中任何命名空间中的 secret 。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell><span class=c1># 以下`ClusterRoleBinding`对象允许在用户组&#34;manager&#34;中的任何用户都可以读取集群中任何命名空间中的secret。</span>
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: read-secrets-global
subjects:
- kind: Group
  name: manager
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
</code></pre></td></tr></table></div></div><h3 id=默认角色-与-默认角色绑定>默认角色 与 默认角色绑定</h3><ul><li><p>API Server 会创建一组默认的 ClusterRole 和 ClusterRoleBinding 对象。这些默认对象中有许多包含 system: 前缀，表明这些资源由 Kubernetes基础组件”拥有”。对这些资源的修改可能导致非功能性集群（non-functional cluster）。</p></li><li><p><code>system:node</code> ClusterRole 对象。这个角色定义了 kubelet 的权限。如果这个角色被修改，可能会导致kubelet 无法正常工作。</p></li><li><p>所有默认的 ClusterRole 和 ClusterRoleBinding 对象都会被标记为 kubernetes.io/bootstrapping=rbac-defaults。</p></li></ul><h3 id=用户角色>用户角色</h3><ul><li><p>通过命令 <code>kubectl get clusterrole</code> 查看到并不是所有都是以 system:前缀，它们是面向用户的角色。这些角色包含超级用户角色（cluster-admin），即旨在利用 ClusterRoleBinding（cluster-status）在集群范围内授权的角色， 以及那些使用 RoleBinding（admin、edit和view）在特定命名空间中授权的角色。</p><ul><li><p><code>cluster-admin</code> 超级用户权限，允许对任何资源执行任何操作。在 ClusterRoleBinding 中使用时，可以完全控制集群和所有命名空间中的所有资源。在 RoleBinding 中使用时，可以完全控制 RoleBinding 所在命名空间中的所有资源，包括命名空间自己。</p></li><li><p><code>admin</code> 管理员权限，利用 RoleBinding 在某一命名空间内部授予。在 RoleBinding 中使用时，允许针对命名空间内大部分资源的读写访问， 包括在命名空间内创建角色与角色绑定的能力。但不允许对资源配额（resource quota）或者命名空间本身的写访问。</p></li><li><p><code>edit</code> 允许对某一个命名空间内大部分对象的读写访问，但不允许查看或者修改角色或者角色绑定。</p></li><li><p><code>view</code> 允许对某一个命名空间内大部分对象的只读访问。不允许查看角色或者角色绑定。由于可扩散性等原因，不允许查看 secret 资源。</p></li></ul></li></ul><h2 id=api-server-认证机制>API Server 认证机制</h2><ul><li><p>通常我们使用客户端 <code>kubectl</code> 来与<code>Kubernetes API Server</code> 交互, 它们之间的接口是REST调用。</p></li><li><p>为了确保 <code>Kubernetes</code> 集群的安全，<code>API Server</code> 都会对客户端进行身份认证，认证失败则无法调用API。</p></li><li><p>Pod中访问<code>Kubernetes API Server</code>服务的时候，是以<code>Service</code>方式访问服务名为<code>kubernetes</code>的这个服务，而<code>kubernetes</code>服务又只在HTTPS 443上提供服务，那么如何进行身份认证呢?</p><ul><li><code>Service Account Token</code></li></ul></li><li><p><code>Kubernetes</code>   有两套账户系统分别是</p><ul><li><p>1.  <code>User Account</code> 是给用户使用的, 是全局性的, 主要用于 后端的用户数据库同步。</p></li><li><p>2.  <code>Service Account</code> 是给 <code>Pod</code> 内的进程使用的, 是属于具体的 <code>Namespace</code> 的。</p></li></ul></li></ul><h3 id=service-account>Service Account</h3><blockquote><p>每个Namespace下有一个名为default的默认的Service Account对象，这个Service Account里面有一个名为Tokens的可以当作Volume一样被Mount到Podcast里的Secret,当Pod 启动时，这个Secret会自动被Mount到Pod的指定目录下，用来协助完成Pod中的进程访问API Server时的身份鉴权过程。</p></blockquote><ul><li><code>kubernetes</code> 开启了 <code>Service Account</code> 会在每个 <code>Namespace</code> 下面都会创建一个默认的 <code>default</code> 的<code>Service Account</code>。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>[root@k8s-node-1 ~]# kubectl get sa --all-namespaces |grep default
default              default                                   1         13d
ingress-nginx        default                                   1         7d16h
istio-system         default                                   1         2d20h
jicki                default                                   1         2d18h
kube-system          default                                   1         13d
</code></pre></td></tr></table></div></div><ul><li>每个<code>Service Account</code> 下面都会拥有一个加密过的<code>secret</code> 作为<code>Token</code>。 这个<code>Token</code> 就是 <code>Service Account Token</code> 。这个 <code>Token</code> 才是真正在 <code>API Server</code> 验证(authentication)环节起作用的。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>[root@k8s-node-1 ~]# kubectl get sa/default -o yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: &#34;2020-04-03T10:06:15Z&#34;
  name: default
  namespace: default
  resourceVersion: &#34;372&#34;
  selfLink: /api/v1/namespaces/default/serviceaccounts/default
  uid: 23344d2a-08e1-447c-a62e-73b821fcc5ce
secrets:
- name: default-token-9bcmt
</code></pre></td></tr></table></div></div><ul><li>当用户在该<code>Namespace</code> 下创建 <code>pod</code> 的时候都会默认使用这个<code>Service Account</code> 。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>[root@k8s-node-1 ~]# kubectl get pods/nginx -o yaml
apiVersion: v1
kind: Pod
metadata:
 .....

spec:
  containers:
  - image: nginx:alpine
    imagePullPolicy: IfNotPresent
    name: nginx
    resources: {}
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: default-token-9bcmt
      readOnly: true

 ....

  volumes:
  - name: default-token-9bcmt
    secret:
      defaultMode: 420
      secretName: default-token-9bcmt

</code></pre></td></tr></table></div></div><ul><li><p>查看 <code>secret</code> 的具体内容</p><ul><li><p><code>ca.crt</code>   这个是<code>API Server</code>的 <code>CA</code>公钥证书, 用于<code>Pod</code> 中的 <code>Process</code> 对 <code>API Server</code> 的服务端数字证书进行校验时使用</p></li><li><p><code>Namespace</code> 和 <code>Token</code> 被放到了容器内, 这样容器内就可以通过<code>https</code>的方式通过 SVC - <code>kubernetes</code> 请求访问<code>API Server</code> 。</p></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>[root@k8s-node-1 ~]# kubectl get secrets default-token-9bcmt -o yaml
apiVersion: v1
data:
  ca.crt: {base64}
  namespace: ZGVmYXVsdA== 
  token: {base64}
kind: Secret

  ....

type: kubernetes.io/service-account-token
</code></pre></td></tr></table></div></div><ul><li><p><code>Secret</code></p><ul><li><p><code>Kubernetes</code> 提供了 <code>Secret</code> 来处理敏感信息, 目前<code>Secret</code>的类型有3种</p><ul><li><p>1.  <code>Opaque</code> (default):  任意字符串。</p></li><li><p>2.  <code>kubernetes.io/service-account-token</code>:  作用于 <code>Service Account</code> 。</p></li><li><p>3.  <code>kubernetes.io/dockercfg</code>:  作用于<code>Docker registry</code>, 用于下载Docker镜像认证使用。</p></li></ul></li></ul></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2018-01-01</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/kubernetes-popularization/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://jicki.cn/kubernetes-popularization/ data-title="kubernetes 基础知识" data-via=jicki234><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://jicki.cn/kubernetes-popularization/><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://jicki.cn/kubernetes-popularization/ data-title="kubernetes 基础知识" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://jicki.cn/kubernetes-popularization/ data-title="kubernetes 基础知识"><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://jicki.cn/kubernetes-popularization/ data-title="kubernetes 基础知识"><i class="fab fa-weibo fa-fw"></i></a><a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=https://jicki.cn/kubernetes-popularization/ data-title="kubernetes 基础知识" data-description="kubernetes 基础知识"><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg></i></a><a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://jicki.cn/kubernetes-popularization/ data-title="kubernetes 基础知识" data-description="kubernetes 基础知识"><i class="fab fa-blogger fa-fw"></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://jicki.cn/kubernetes-popularization/ data-title="kubernetes 基础知识"><i class="fab fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/kubernetes-1.9-ipvs/ class=prev rel=prev title="kubernetes 1.9.0 ipvs coreDNS"><i class="fas fa-angle-left fa-fw"></i>kubernetes 1.9.0 ipvs coreDNS</a>
<a href=/openshift-3.7.0/ class=next rel=next title="openshift origin 3.7">openshift origin 3.7<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.73.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://jicki.cn target=_blank>小炒肉</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp>粤ICP备20055633号</span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>